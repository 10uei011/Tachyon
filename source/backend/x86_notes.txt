/*
Implicit zero extend

Results of 32-bit operations are implicitly zero extended to 64-bit values.
This differs from 16 and 8 bit operations, that don't affect the upper part
of registers. This can be used for code size optimisations in some cases,
such as:

  movl $1, %eax         # one byte shorter movq $1, %rax
  xorq %rax, %rax		# three byte equivalent of mov $0,%rax
  andl $5, %eax			# equivalent for andq $5, %eax

Instructions on
32-bit integers automatically zero-extend their results
to 64 bits (32-bit operands are default on AMD64),
while instructions on 16 or 8-bit integers leave the
higher bits unchanged.
*/

/*
64-bit mode Immediates

Immediate values inside instructions remain 32 bits and their value is sign
extended to 64 bits before calculation. This means that:

  addq $1, %rax		         # Valid instruction
  addq $0x7fffffff, %rax	 # As this
  addq $0xffffffffffffffff, %rax # as this one
  addq $0xffffffff, %rax	 # Invalid instruction
  addl $0xffffffff, %eax	 # Valid instruction

Only exception from this rule are the moves of constant to registers that
have 64bit form.

Loads and stores with 64bit displacement are available only for the eax
instruction.
*/

/*
R13 addressing limitations
==========================
The R13 is upper-halve equivalent of RBP, that is used in MODRM encoding
to escape out into SIB.  The R13 also does the encoding (to prevent REX
prefix from changing instruction length), so pretty much same limitations
to RBP addressing apply to the R13.  This means that
  (%rbp,index,scale)
is not encodable and:
  0(%rbp,index,scale)
must be used.

R12 and R13 have quirks corresponding to ESP and EBP.
*/

/*
The dynamic branch prediction hardware has a buffer that remembers whether a given
branch is likely to be taken or not. When a branch is not listed in the buffer, the static
predictor assumes that backward branches are taken, and forward branches are not taken.
This means that an efficient compiler should pay attention to how it constructs traces and
linearizes its code.

Enable good branch prediction. Arrange code to follow the static branch predictor's
rules. Ensure that each ret instruction is preceded by a corresponding call instruction:
do not bypass the call stack or manipulate the return addresses within it.

Keep variables permanently in registers when possible. If this is not possible, it is generally
better to use memory operands in instructions than to read variables into temporary
registers before each use. Reloading spilled temporaries into registers might cause
other temporaries to spill.

Detecting the need for a REX prefix is easily done while the assembler is encoding an
instruction: any use of a high register number (8-15) or a 64-bit operation triggers it.
*/

/*
x86 instruction format:

prefix(es)  [REX] opcode  [XRM  [SIB]]  disp  imm

Not all instructions require a REX prefix in 64-bit mode. A prefix is
necessary only if an instruction references one of the extended registers or
uses a 64-bit operand. If a REX prefix is used when it has no meaning, it is
ignored.

SIB byte isn't always necessary for all XRM encodings.

REX prefix encoding: 0100wrxb (binary)
w: Sets 64-bit operand size (default is still 32-bit)
r: Bit 3 of Reg in ModRM
x: Bit 3 of Index in SIB
b: Bit 3 of RM in ModRM or Base in SIB, or opcode reg field

The REX prefix replaces the single-byte INC/DEC opcodes (10r/11r).

Instruction formats are described in the reference manual.
These parameters should probably be encoded. Perhaps they
should be used by the encoding function? This would
allow this function to know what operands are valid.

- Does the instruction take a reverse flag?
- Does it take an operand size flag?
- Sign-extend flag?
- Default operand size?
*/

// TODO: How do we differentiate between ax,imm16
// and eax,imm32 here, in terms of encoding??
// The 16-bit version requires an operand size prefix

// TODO: this instruction will sign-extend imm8 only if a REX prefix
// is specified...
//
// The REX flag in the doc is there only to say that the instr semantics
// may change when the prefix is added. Some one-byte reg encodings
// become impossible with the REX prefix.

